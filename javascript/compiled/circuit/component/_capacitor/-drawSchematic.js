"use strict";
var Circuit;
(function (Circuit) {
    var Component;
    (function (Component) {
        var _Capacitor;
        (function (_Capacitor) {
            function drawSchematic(instance) {
                const bodyGroup = Svg.Element.Group.make("body");
                const cathodeEnd = instance.joints[_Capacitor.INDEXCATHODE];
                const anodeEnd = instance.joints[_Capacitor.INDEXANODE];
                let centre = vector(cathodeEnd, anodeEnd).centre().vector;
                let rotation = vector(cathodeEnd).getAngleTo(anodeEnd);
                let [cathodeStart, anodeStart] = vector({ x: -6, y: 0 }, { x: 6, y: 0 }).rotate(rotation).sumWith(centre).vectors;
                let text = Utility.getStandardForm(instance.capacitance, 'F');
                bodyGroup.append(Svg.Element.Rect.make(vector(0), { width: 15, height: 30 }, vector(2), "highlight highlightwithfill extrathick"), Svg.Element.Line.make({ x: -4, y: -15 }, { x: -4, y: +15 }, "line thick nocap"), Svg.Element.Line.make({ x: +4, y: -15 }, { x: +4, y: +15 }, "line thick nocap"));
                if (instance.isPolarised) {
                    bodyGroup.append(Svg.Element.Path.make([
                        [{ x: +15, y: -10 }, { x: +7, y: -10 }],
                        [{ x: +11, y: -6 }, { x: +11, y: -14 }]
                    ], "line thin"));
                }
                return [
                    Svg.Element.Path.make([[cathodeStart, cathodeEnd], [anodeStart, anodeEnd]], "line thin"),
                    bodyGroup.translate(centre).rotate(rotation),
                    Svg.Element.Text.make(text, { x: 0, y: -20 }, "text").translate(centre).rotatePosition(rotation)
                ];
            }
            _Capacitor.drawSchematic = drawSchematic;
        })(_Capacitor = Component._Capacitor || (Component._Capacitor = {}));
    })(Component = Circuit.Component || (Circuit.Component = {}));
})(Circuit || (Circuit = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLWRyYXdTY2hlbWF0aWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90eXBlc2NyaXB0L2NpcmN1aXQvY29tcG9uZW50L19jYXBhY2l0b3IvLWRyYXdTY2hlbWF0aWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLElBQVUsT0FBTyxDQW9DaEI7QUFwQ0QsV0FBVSxPQUFPO0lBQUMsSUFBQSxTQUFTLENBb0MxQjtJQXBDaUIsV0FBQSxTQUFTO1FBQUMsSUFBQSxVQUFVLENBb0NyQztRQXBDMkIsV0FBQSxVQUFVO1lBQ25DLFNBQWdCLGFBQWEsQ0FBQyxRQUEyQjtnQkFDdEQsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUVqRCxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFdBQUEsWUFBWSxDQUFDLENBQUM7Z0JBQ2pELE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsV0FBQSxVQUFVLENBQUMsQ0FBQztnQkFFN0MsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7Z0JBQzFELElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRXZELElBQUksQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLEdBQWEsTUFBTSxDQUM5QyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FDakMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQztnQkFHM0MsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFBO2dCQUU3RCxTQUFTLENBQUMsTUFBTSxDQUNiLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsd0NBQXdDLENBQUMsRUFDaEgsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLGtCQUFrQixDQUFDLEVBQy9FLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxrQkFBa0IsQ0FBQyxDQUNqRixDQUFDO2dCQUVGLElBQUksUUFBUSxDQUFDLFdBQVcsRUFBRTtvQkFDdkIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7d0JBQ3BDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7d0JBQ3ZDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7cUJBQ3pDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztpQkFDbkI7Z0JBRUQsT0FBTztvQkFDSixHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQztvQkFDeEYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO29CQUM1QyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQztpQkFDbEcsQ0FBQztZQUNMLENBQUM7WUFsQ2Usd0JBQWEsZ0JBa0M1QixDQUFBO1FBQ0osQ0FBQyxFQXBDMkIsVUFBVSxHQUFWLG9CQUFVLEtBQVYsb0JBQVUsUUFvQ3JDO0lBQUQsQ0FBQyxFQXBDaUIsU0FBUyxHQUFULGlCQUFTLEtBQVQsaUJBQVMsUUFvQzFCO0FBQUQsQ0FBQyxFQXBDUyxPQUFPLEtBQVAsT0FBTyxRQW9DaEIiLCJzb3VyY2VzQ29udGVudCI6WyJuYW1lc3BhY2UgQ2lyY3VpdC5Db21wb25lbnQuX0NhcGFjaXRvciB7XHJcbiAgIGV4cG9ydCBmdW5jdGlvbiBkcmF3U2NoZW1hdGljKGluc3RhbmNlOiBDbGFzc2VzLlNjaGVtYXRpYykge1xyXG4gICAgICBjb25zdCBib2R5R3JvdXAgPSBTdmcuRWxlbWVudC5Hcm91cC5tYWtlKFwiYm9keVwiKTtcclxuXHJcbiAgICAgIGNvbnN0IGNhdGhvZGVFbmQgPSBpbnN0YW5jZS5qb2ludHNbSU5ERVhDQVRIT0RFXTtcclxuICAgICAgY29uc3QgYW5vZGVFbmQgPSBpbnN0YW5jZS5qb2ludHNbSU5ERVhBTk9ERV07XHJcblxyXG4gICAgICBsZXQgY2VudHJlID0gdmVjdG9yKGNhdGhvZGVFbmQsIGFub2RlRW5kKS5jZW50cmUoKS52ZWN0b3I7XHJcbiAgICAgIGxldCByb3RhdGlvbiA9IHZlY3RvcihjYXRob2RlRW5kKS5nZXRBbmdsZVRvKGFub2RlRW5kKTtcclxuXHJcbiAgICAgIGxldCBbY2F0aG9kZVN0YXJ0LCBhbm9kZVN0YXJ0XTogVmVjdG9yW10gPSB2ZWN0b3IoXHJcbiAgICAgICAgIHsgeDogLTYsIHk6IDAgfSwgeyB4OiA2LCB5OiAwIH1cclxuICAgICAgKS5yb3RhdGUocm90YXRpb24pLnN1bVdpdGgoY2VudHJlKS52ZWN0b3JzO1xyXG5cclxuICAgICAgLy9UZXh0XHJcbiAgICAgIGxldCB0ZXh0ID0gVXRpbGl0eS5nZXRTdGFuZGFyZEZvcm0oaW5zdGFuY2UuY2FwYWNpdGFuY2UsICdGJylcclxuXHJcbiAgICAgIGJvZHlHcm91cC5hcHBlbmQoXHJcbiAgICAgICAgIFN2Zy5FbGVtZW50LlJlY3QubWFrZSh2ZWN0b3IoMCksIHsgd2lkdGg6IDE1LCBoZWlnaHQ6IDMwIH0sIHZlY3RvcigyKSwgXCJoaWdobGlnaHQgaGlnaGxpZ2h0d2l0aGZpbGwgZXh0cmF0aGlja1wiKSxcclxuICAgICAgICAgU3ZnLkVsZW1lbnQuTGluZS5tYWtlKHsgeDogLTQsIHk6IC0xNSB9LCB7IHg6IC00LCB5OiArMTUgfSwgXCJsaW5lIHRoaWNrIG5vY2FwXCIpLFxyXG4gICAgICAgICBTdmcuRWxlbWVudC5MaW5lLm1ha2UoeyB4OiArNCwgeTogLTE1IH0sIHsgeDogKzQsIHk6ICsxNSB9LCBcImxpbmUgdGhpY2sgbm9jYXBcIiksXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UuaXNQb2xhcmlzZWQpIHtcclxuICAgICAgICAgYm9keUdyb3VwLmFwcGVuZChTdmcuRWxlbWVudC5QYXRoLm1ha2UoW1xyXG4gICAgICAgICAgICBbeyB4OiArMTUsIHk6IC0xMCB9LCB7IHg6ICs3LCB5OiAtMTAgfV0sXHJcbiAgICAgICAgICAgIFt7IHg6ICsxMSwgeTogLTYgfSwgeyB4OiArMTEsIHk6IC0xNCB9XVxyXG4gICAgICAgICBdLCBcImxpbmUgdGhpblwiKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgIFN2Zy5FbGVtZW50LlBhdGgubWFrZShbW2NhdGhvZGVTdGFydCwgY2F0aG9kZUVuZF0sIFthbm9kZVN0YXJ0LCBhbm9kZUVuZF1dLCBcImxpbmUgdGhpblwiKSxcclxuICAgICAgICAgYm9keUdyb3VwLnRyYW5zbGF0ZShjZW50cmUpLnJvdGF0ZShyb3RhdGlvbiksXHJcbiAgICAgICAgIFN2Zy5FbGVtZW50LlRleHQubWFrZSh0ZXh0LCB7IHg6IDAsIHk6IC0yMCB9LCBcInRleHRcIikudHJhbnNsYXRlKGNlbnRyZSkucm90YXRlUG9zaXRpb24ocm90YXRpb24pXHJcbiAgICAgIF07XHJcbiAgIH1cclxufVxyXG4iXX0=